### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Collection {
  createdAt: DateTime!
  detail: String
  id: ID!
  isDeleted: Boolean!
  items(after: ID, before: ID, first: Int, last: Int, orderBy: CollectionItemsOrderByInput, skip: Int, where: CollectionItemsWhereInput): [Item!]!
  name: String
  owner: User!
  section: Section!
  slug: String!
}

input CollectionCreateInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  items: ItemCreateManyWithoutItemsInput
  name: String
  owner: UserCreateOneWithoutOwnerInput!
  section: SectionCreateOneWithoutSectionInput!
  slug: String!
}

input CollectionCreateManyWithoutCollectionsInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutSectionInput!]
}

input CollectionCreateWithoutItemsInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  name: String
  owner: UserCreateOneWithoutOwnerInput!
  section: SectionCreateOneWithoutSectionInput!
  slug: String!
}

input CollectionCreateWithoutOwnerInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  items: ItemCreateManyWithoutItemsInput
  name: String
  section: SectionCreateOneWithoutSectionInput!
  slug: String!
}

input CollectionCreateWithoutSectionInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  items: ItemCreateManyWithoutItemsInput
  name: String
  owner: UserCreateOneWithoutOwnerInput!
  slug: String!
}

input CollectionFilter {
  every: CollectionWhereInput
  none: CollectionWhereInput
  some: CollectionWhereInput
}

input CollectionItemsOrderByInput {
  position: OrderByArg
}

input CollectionItemsWhereInput {
  isArchived: BooleanFilter
}

input CollectionScalarWhereInput {
  AND: [CollectionScalarWhereInput!]
  createdAt: DateTimeFilter
  detail: NullableStringFilter
  id: StringFilter
  isDeleted: BooleanFilter
  items: ItemFilter
  name: NullableStringFilter
  NOT: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  slug: StringFilter
}

input CollectionUpdateInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  items: ItemUpdateManyWithoutCollectionInput
  name: String
  owner: UserUpdateOneRequiredWithoutCollectionsInput
  section: SectionUpdateOneRequiredWithoutCollectionsInput
  slug: String
}

input CollectionUpdateManyDataInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  name: String
  slug: String
}

input CollectionUpdateManyWithoutOwnerInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutOwnerInput!]
  delete: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  disconnect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [CollectionUpdateManyWithWhereNestedInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutOwnerInput!]
}

input CollectionUpdateManyWithoutSectionInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutSectionInput!]
  delete: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  disconnect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutSectionInput!]
  updateMany: [CollectionUpdateManyWithWhereNestedInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutSectionInput!]
}

input CollectionUpdateManyWithWhereNestedInput {
  data: CollectionUpdateManyDataInput!
  where: CollectionScalarWhereInput!
}

input CollectionUpdateOneWithoutItemsInput {
  connect: CollectionWhereUniqueInput
  create: CollectionCreateWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  update: CollectionUpdateWithoutItemsDataInput
  upsert: CollectionUpsertWithoutItemsInput
}

input CollectionUpdateWithoutItemsDataInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  name: String
  owner: UserUpdateOneRequiredWithoutCollectionsInput
  section: SectionUpdateOneRequiredWithoutCollectionsInput
  slug: String
}

input CollectionUpdateWithoutOwnerDataInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  items: ItemUpdateManyWithoutCollectionInput
  name: String
  section: SectionUpdateOneRequiredWithoutCollectionsInput
  slug: String
}

input CollectionUpdateWithoutSectionDataInput {
  createdAt: DateTime
  detail: String
  id: ID
  isDeleted: Boolean
  items: ItemUpdateManyWithoutCollectionInput
  name: String
  owner: UserUpdateOneRequiredWithoutCollectionsInput
  slug: String
}

input CollectionUpdateWithWhereUniqueWithoutOwnerInput {
  data: CollectionUpdateWithoutOwnerDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpdateWithWhereUniqueWithoutSectionInput {
  data: CollectionUpdateWithoutSectionDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithoutItemsInput {
  create: CollectionCreateWithoutItemsInput!
  update: CollectionUpdateWithoutItemsDataInput!
}

input CollectionUpsertWithWhereUniqueWithoutOwnerInput {
  create: CollectionCreateWithoutOwnerInput!
  update: CollectionUpdateWithoutOwnerDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithWhereUniqueWithoutSectionInput {
  create: CollectionCreateWithoutSectionInput!
  update: CollectionUpdateWithoutSectionDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  createdAt: DateTimeFilter
  detail: NullableStringFilter
  id: StringFilter
  isDeleted: BooleanFilter
  items: ItemFilter
  name: NullableStringFilter
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  owner: UserWhereInput
  section: SectionWhereInput
  slug: StringFilter
}

input CollectionWhereUniqueInput {
  id: ID
  slug: String
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Item {
  author: String
  comment: String
  createdAt: DateTime!
  description: String
  id: ID!
  imageUrl: String
  isArchived: Boolean!
  meta: String
  position: Int!
  productUrl: String
  provider: String
  title: String!
  type: ItemType!
}

input ItemCreateManyWithoutItemsInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutCollectionInput!]
}

input ItemCreateWithoutCollectionInput {
  author: String
  comment: String
  createdAt: DateTime
  description: String
  id: ID
  imageUrl: String
  isArchived: Boolean
  meta: String
  position: Int
  productUrl: String
  provider: String
  title: String!
  type: ItemType!
  updatedAt: DateTime
}

input ItemFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput!]
  author: NullableStringFilter
  comment: NullableStringFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: StringFilter
  imageUrl: NullableStringFilter
  isArchived: BooleanFilter
  meta: NullableStringFilter
  NOT: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  position: IntFilter
  productUrl: NullableStringFilter
  provider: NullableStringFilter
  title: StringFilter
  type: ItemType
  updatedAt: DateTimeFilter
}

enum ItemType {
  album
  article
  book
  movie
  people
  podcast
  repository
  video
  website
}

input ItemUpdateInput {
  author: String
  collection: CollectionUpdateOneWithoutItemsInput
  comment: String
  createdAt: DateTime
  description: String
  id: ID
  imageUrl: String
  isArchived: Boolean
  meta: String
  position: Int
  productUrl: String
  provider: String
  title: String
  type: ItemType
  updatedAt: DateTime
}

input ItemUpdateManyDataInput {
  author: String
  comment: String
  createdAt: DateTime
  description: String
  id: ID
  imageUrl: String
  isArchived: Boolean
  meta: String
  position: Int
  productUrl: String
  provider: String
  title: String
  type: ItemType
  updatedAt: DateTime
}

input ItemUpdateManyWithoutCollectionInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutCollectionInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutCollectionInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  data: ItemUpdateManyDataInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateWithoutCollectionDataInput {
  author: String
  comment: String
  createdAt: DateTime
  description: String
  id: ID
  imageUrl: String
  isArchived: Boolean
  meta: String
  position: Int
  productUrl: String
  provider: String
  title: String
  type: ItemType
  updatedAt: DateTime
}

input ItemUpdateWithWhereUniqueWithoutCollectionInput {
  data: ItemUpdateWithoutCollectionDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutCollectionInput {
  create: ItemCreateWithoutCollectionInput!
  update: ItemUpdateWithoutCollectionDataInput!
  where: ItemWhereUniqueInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  author: NullableStringFilter
  collection: CollectionWhereInput
  comment: NullableStringFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: StringFilter
  imageUrl: NullableStringFilter
  isArchived: BooleanFilter
  meta: NullableStringFilter
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  position: IntFilter
  productUrl: NullableStringFilter
  provider: NullableStringFilter
  title: StringFilter
  type: ItemType
  updatedAt: DateTimeFilter
}

input ItemWhereUniqueInput {
  id: ID
}

type Mutation {
  """
  Mutation changing the position of an item from his $oldIndex to the $newIndex.
              It takes *indexes* (not position) and return changed items with new position.
              
  """
  changeItemPosition(collectionId: ID!, newIndex: Int!, oldIndex: Int!): [Item!]!
  createItemFromSearch(collectionId: String!, id: String!, kind: String!): Item!
  createItemFromUrl(collectionId: String!, url: String!): Item!
  createOneCollection(data: CollectionCreateInput!): Collection!
  createOneSection(data: SectionCreateInput!): Section!
  createOneUser(data: UserCreateInput!): User!
  updateOneCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection
  updateOneItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateOneSection(data: SectionUpdateInput!, where: SectionWhereUniqueInput!): Section
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  collection(where: CollectionWhereUniqueInput!): Collection
  collections(after: ID, before: ID, first: Int, last: Int, orderBy: QueryCollectionsOrderByInput, skip: Int, where: QueryCollectionsWhereInput): [Collection!]!
  items(after: ID, before: ID, first: Int, last: Int, orderBy: QueryItemsOrderByInput, skip: Int, where: QueryItemsWhereInput): [Item!]!
  search(kind: String!, q: String!): [SearchItem!]!
  section(where: SectionWhereUniqueInput!): Section
  sections(after: ID, before: ID, first: Int, last: Int, skip: Int, where: QuerySectionsWhereInput): [Section!]!
  user(where: UserWhereUniqueInput!): User
}

input QueryCollectionsOrderByInput {
  createdAt: OrderByArg
}

input QueryCollectionsWhereInput {
  isDeleted: BooleanFilter
  owner: UserWhereInput
  section: SectionWhereInput
}

input QueryItemsOrderByInput {
  position: OrderByArg
}

input QueryItemsWhereInput {
  collection: CollectionWhereInput
  isArchived: BooleanFilter
}

input QuerySectionsWhereInput {
  owner: UserWhereInput
}

type SearchItem {
  author: String
  id: String!
  title: String!
  type: String!
}

type Section {
  collections(after: ID, before: ID, first: Int, last: Int, skip: Int, where: SectionCollectionsWhereInput): [Collection!]!
  id: ID!
  index: Int!
  isExpanded: Boolean!
  name: String
  slug: String!
}

input SectionCollectionsWhereInput {
  isDeleted: BooleanFilter
}

input SectionCreateInput {
  collections: CollectionCreateManyWithoutCollectionsInput
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  owner: UserCreateOneWithoutOwnerInput!
  slug: String!
  updatedAt: DateTime
}

input SectionCreateManyWithoutSectionsInput {
  connect: [SectionWhereUniqueInput!]
  create: [SectionCreateWithoutOwnerInput!]
}

input SectionCreateOneWithoutSectionInput {
  connect: SectionWhereUniqueInput
  create: SectionCreateWithoutCollectionsInput
}

input SectionCreateWithoutCollectionsInput {
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  owner: UserCreateOneWithoutOwnerInput!
  slug: String!
  updatedAt: DateTime
}

input SectionCreateWithoutOwnerInput {
  collections: CollectionCreateManyWithoutCollectionsInput
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  slug: String!
  updatedAt: DateTime
}

input SectionFilter {
  every: SectionWhereInput
  none: SectionWhereInput
  some: SectionWhereInput
}

input SectionScalarWhereInput {
  AND: [SectionScalarWhereInput!]
  collections: CollectionFilter
  createdAt: DateTimeFilter
  id: StringFilter
  index: IntFilter
  isExpanded: BooleanFilter
  name: NullableStringFilter
  NOT: [SectionScalarWhereInput!]
  OR: [SectionScalarWhereInput!]
  slug: StringFilter
  updatedAt: DateTimeFilter
}

input SectionUpdateInput {
  collections: CollectionUpdateManyWithoutSectionInput
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  owner: UserUpdateOneRequiredWithoutSectionsInput
  slug: String
  updatedAt: DateTime
}

input SectionUpdateManyDataInput {
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  slug: String
  updatedAt: DateTime
}

input SectionUpdateManyWithoutOwnerInput {
  connect: [SectionWhereUniqueInput!]
  create: [SectionCreateWithoutOwnerInput!]
  delete: [SectionWhereUniqueInput!]
  deleteMany: [SectionScalarWhereInput!]
  disconnect: [SectionWhereUniqueInput!]
  set: [SectionWhereUniqueInput!]
  update: [SectionUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [SectionUpdateManyWithWhereNestedInput!]
  upsert: [SectionUpsertWithWhereUniqueWithoutOwnerInput!]
}

input SectionUpdateManyWithWhereNestedInput {
  data: SectionUpdateManyDataInput!
  where: SectionScalarWhereInput!
}

input SectionUpdateOneRequiredWithoutCollectionsInput {
  connect: SectionWhereUniqueInput
  create: SectionCreateWithoutCollectionsInput
  update: SectionUpdateWithoutCollectionsDataInput
  upsert: SectionUpsertWithoutCollectionsInput
}

input SectionUpdateWithoutCollectionsDataInput {
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  owner: UserUpdateOneRequiredWithoutSectionsInput
  slug: String
  updatedAt: DateTime
}

input SectionUpdateWithoutOwnerDataInput {
  collections: CollectionUpdateManyWithoutSectionInput
  createdAt: DateTime
  id: ID
  index: Int
  isExpanded: Boolean
  name: String
  slug: String
  updatedAt: DateTime
}

input SectionUpdateWithWhereUniqueWithoutOwnerInput {
  data: SectionUpdateWithoutOwnerDataInput!
  where: SectionWhereUniqueInput!
}

input SectionUpsertWithoutCollectionsInput {
  create: SectionCreateWithoutCollectionsInput!
  update: SectionUpdateWithoutCollectionsDataInput!
}

input SectionUpsertWithWhereUniqueWithoutOwnerInput {
  create: SectionCreateWithoutOwnerInput!
  update: SectionUpdateWithoutOwnerDataInput!
  where: SectionWhereUniqueInput!
}

input SectionWhereInput {
  AND: [SectionWhereInput!]
  collections: CollectionFilter
  createdAt: DateTimeFilter
  id: StringFilter
  index: IntFilter
  isExpanded: BooleanFilter
  name: NullableStringFilter
  NOT: [SectionWhereInput!]
  OR: [SectionWhereInput!]
  owner: UserWhereInput
  slug: StringFilter
  updatedAt: DateTimeFilter
}

input SectionWhereUniqueInput {
  id: ID
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  authUserId: String
  biography: String!
  firstname: String!
  github: String
  id: ID!
  label: String
  linkedin: String
  mail: String
  pictureUrl: String!
  sections(after: ID, before: ID, first: Int, last: Int, skip: Int): [Section!]!
  slug: String!
  website: String
  youtube: String
}

input UserCreateInput {
  authUserId: String
  biography: String!
  collections: CollectionCreateManyWithoutCollectionsInput
  createdAt: DateTime
  firstname: String!
  github: String
  id: ID
  label: String
  linkedin: String
  mail: String
  pictureUrl: String!
  sections: SectionCreateManyWithoutSectionsInput
  slug: String!
  website: String
  youtube: String
}

input UserCreateOneWithoutOwnerInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCollectionsInput
}

input UserCreateWithoutCollectionsInput {
  authUserId: String
  biography: String!
  createdAt: DateTime
  firstname: String!
  github: String
  id: ID
  label: String
  linkedin: String
  mail: String
  pictureUrl: String!
  sections: SectionCreateManyWithoutSectionsInput
  slug: String!
  website: String
  youtube: String
}

input UserCreateWithoutSectionsInput {
  authUserId: String
  biography: String!
  collections: CollectionCreateManyWithoutCollectionsInput
  createdAt: DateTime
  firstname: String!
  github: String
  id: ID
  label: String
  linkedin: String
  mail: String
  pictureUrl: String!
  slug: String!
  website: String
  youtube: String
}

input UserUpdateOneRequiredWithoutCollectionsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCollectionsInput
  update: UserUpdateWithoutCollectionsDataInput
  upsert: UserUpsertWithoutCollectionsInput
}

input UserUpdateOneRequiredWithoutSectionsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutSectionsInput
  update: UserUpdateWithoutSectionsDataInput
  upsert: UserUpsertWithoutSectionsInput
}

input UserUpdateWithoutCollectionsDataInput {
  authUserId: String
  biography: String
  createdAt: DateTime
  firstname: String
  github: String
  id: ID
  label: String
  linkedin: String
  mail: String
  pictureUrl: String
  sections: SectionUpdateManyWithoutOwnerInput
  slug: String
  website: String
  youtube: String
}

input UserUpdateWithoutSectionsDataInput {
  authUserId: String
  biography: String
  collections: CollectionUpdateManyWithoutOwnerInput
  createdAt: DateTime
  firstname: String
  github: String
  id: ID
  label: String
  linkedin: String
  mail: String
  pictureUrl: String
  slug: String
  website: String
  youtube: String
}

input UserUpsertWithoutCollectionsInput {
  create: UserCreateWithoutCollectionsInput!
  update: UserUpdateWithoutCollectionsDataInput!
}

input UserUpsertWithoutSectionsInput {
  create: UserCreateWithoutSectionsInput!
  update: UserUpdateWithoutSectionsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  authUserId: NullableStringFilter
  biography: StringFilter
  collections: CollectionFilter
  createdAt: DateTimeFilter
  firstname: StringFilter
  github: NullableStringFilter
  id: StringFilter
  label: NullableStringFilter
  linkedin: NullableStringFilter
  mail: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  pictureUrl: StringFilter
  sections: SectionFilter
  slug: StringFilter
  website: NullableStringFilter
  youtube: NullableStringFilter
}

input UserWhereUniqueInput {
  authUserId: String
  id: ID
  slug: String
}
